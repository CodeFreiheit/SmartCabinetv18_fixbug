#include "oled.h"
#include "stm32f10x_gpio.h"
#include "delay.h"
#include "gsm.h"
#include "lwip_comm.h"
#include "gps.h"
#include "adc.h"
#include "sensor.h"



extern nmea_msg gpsxSC;

u32 fontaddr = 0;

extern const char BuildDate[];
extern const char BuildTime[];
extern const char ReleaseVersion[];

u8 const logo[]={
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xC0,0xE0,
0xF0,0xF0,0xF8,0xF8,0xFC,0xFC,0xFC,0xFE,0xFE,0xFE,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFE,0xFE,0xFE,0xFE,0xFC,0xFC,0xF8,0xF8,0xF0,
0xF0,0xE0,0xC0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0x7F,0x3F,0x1F,0x1F,0x0F,0x0F,0x07,0x07,0x03,0x03,0x03,0x03,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x03,0x03,0x03,0x03,0x07,0x07,
0x0F,0x0F,0x1F,0x3F,0x3F,0x7F,0xFE,0xFC,0xF8,0xF0,0xE0,0x80,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0xF0,0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,0x1F,0x07,
0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x40,0x40,0x60,0x60,0xA0,0xE0,
0xA0,0x00,0x80,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x07,0x0F,0x3F,0xFF,0xFE,0xF8,0xE0,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x01,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x58,0x06,0x01,0x20,0xC5,0xD0,0xEF,0xFC,0xFE,0xFE,0xFF,
0xFF,0xFD,0xF5,0x00,0x00,0x07,0x06,0x00,0x05,0x08,0x08,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0xFF,0xFE,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x1F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x0F,0x3C,0x7F,0xFF,0x8B,0x0F,0x0F,0x1F,0x1F,0x3F,0x3F,
0x3F,0xBF,0xFF,0xFF,0xFC,0xFC,0xFC,0xFE,0x7E,0x20,0x08,0xC0,0xE0,0xE0,0xE0,0xE0,
0xE0,0xE0,0xE0,0xE0,0xC0,0xC0,0xC0,0x80,0x80,0x00,0x00,0x00,0x00,0xF8,0xFF,0x7F,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x03,0x1F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC,0xE0,0x80,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x03,0x06,0x04,0x00,0x04,
0x04,0x07,0x07,0x07,0x03,0x01,0x01,0x00,0x00,0x00,0x01,0x0F,0x1F,0x7F,0x7F,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFE,0xFC,0xF9,0xF1,0xE0,
0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x01,0x03,0x07,0x1F,0x3F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFE,0xFC,
0xF8,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x01,0x03,0x87,0x87,0xCF,0xCF,0x1F,0x1F,0x1F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
0x1F,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x03,0x07,0x0F,
0x0F,0x1F,0x1F,0x1F,0x3F,0x3F,0x7F,0x7E,0x7E,0x7C,0x7C,0xFC,0xF8,0xF8,0xF8,0xF0,
0xF0,0xF0,0xF0,0xF0,0xF0,0x70,0x70,0x70,0x78,0x78,0x38,0x3C,0x1C,0x1C,0x1E,0x0E,
0x07,0x07,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};
u8 const GSMGET[]={
0x04,0x08,0x10,0x08,0x84,0x82,0x80,0x00,0xf0,0x10,0xf0,0x00,0xfe,0x02,0xfe,0x00,
0x7c,0x44,0x7c,0x00,0x7f,0x40,0x7f,0x00,0x7f,0x40,0x7f,0x00,0x7f,0x40,0x7f,0x00,
//0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x00,0xf0,0xf0,0xf0,0x00,0xfe,0xfe,0xfe,0x00,
//0x7c,0x7c,0x7c,0x00,0x7f,0x7f,0x7f,0x00,0x7f,0x7f,0x7f,0x00,0x7f,0x7f,0x7f,0x00,
};
u8 const GSMLOSS[]={
0x00,0x22,0x14,0x08,0x94,0xa2,0x80,0x00,0xf0,0x10,0xf0,0x00,0xfe,0x02,0xfe,0x00,
0x7c,0x44,0x7c,0x00,0x7f,0x40,0x7f,0x00,0x7f,0x40,0x7f,0x00,0x7f,0x40,0x7f,0x00,
};
u8 const LANGET[]={
0x00,0x00,0xf8,0x08,0x0e,0x0a,0x0a,0x0a,0x0a,0x0a,0xfa,0xc2,0x7e,0x00,0x00,0x00,
0x00,0x08,0x0d,0x0b,0x09,0x09,0x09,0x09,0x05,0x13,0x21,0x40,0x20,0x10,0x08,0x00,
};
u8 const LANLOSS[]={
0x00,0x00,0xf8,0x08,0x0e,0x0a,0x0a,0x0a,0x0a,0x0a,0xfa,0xc2,0x7e,0x00,0x00,0x00,
0x00,0x08,0x0d,0x0b,0x09,0x09,0x09,0x09,0x05,0x03,0x45,0x28,0x10,0x28,0x44,0x00,
};
u8 const BAT[]={
0xf0,0xf0,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0xf0,0xf0,0xc0,0x80,0x00,
0x0f,0x0f,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0f,0x0f,0x03,0x01,0x00,
};

void GBZK_ROMOUTSET(void)
{
	GPIO_InitTypeDef GPIO_InitStructure;

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
}

void GBZK_ROMOUTRESET(void)
{
	GPIO_InitTypeDef GPIO_InitStructure;
	
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 ;	
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;  
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; 
	GPIO_Init(GPIOA, &GPIO_InitStructure);		  	 
}

void OLED_GPIO_Config(void)
{
	GPIO_InitTypeDef GPIO_InitStructure;

	RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOB, ENABLE);

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOB, &GPIO_InitStructure);

	GPIO_ResetBits(GPIOA,GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7);
	GPIO_ResetBits(GPIOB,GPIO_Pin_0 | GPIO_Pin_1);
//	GPIO_ResetBits(GPIOA,GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6);
//	GPIO_ResetBits(GPIOB,GPIO_Pin_0 | GPIO_Pin_1);


	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
	GPIO_ResetBits(GPIOA,GPIO_Pin_4 );
}

// 写数据到LCD模块
void transfer_data_lcd(int data1)
{
	u8 i;
	
	lcd_rs(1);
	lcd_cs1(0);
	for(i=0; i<8; i++)
	{
		lcd_sclk(0);
		if(data1&0x80){lcd_sid(1);}
		else{lcd_sid(0);}
		lcd_sclk(1);
		__nop();
		//lcd_sclk(0);
	 	data1 <<= 1;
	}
	lcd_rs(1);
	lcd_cs1(1);
}

// 写指令到LCD模块
void transfer_command_lcd(int data1)
{
	u8 i;
	
	lcd_rs(0);
	lcd_cs1(0);
	for(i=0; i<8; i++)
	{
		lcd_sclk(0);
		if(data1&0x80){lcd_sid(1);}
		else{lcd_sid(0);}
		lcd_sclk(1);
		__nop();
	//	lcd_sclk(0);
	 	data1 <<= 1;
	}
	lcd_rs(1);
	lcd_cs1(1);
}

void OLED_Init(void)
{
	delay_ms(400);
	OLED_GPIO_Config();
	lcd_cs1(0);
	Rom_CS(1);

	transfer_command_lcd(0xAE);	// display off
	transfer_command_lcd(0x20);	// Set Memory Addressing Mode	
	transfer_command_lcd(0x10);	// 00,Horizontal Addressing Mode;01,Vertical Addressing Mode;10,Page Addressing Mode (RESET);11,Invalid
	transfer_command_lcd(0xb0);	// Set Page Start Address for Page Addressing Mode,0-7
	transfer_command_lcd(0xc8);	// Set COM Output Scan Direction
	transfer_command_lcd(0x00);	// set low column address
	transfer_command_lcd(0x10);	// set high column address
	transfer_command_lcd(0x40);	// set start line address
	transfer_command_lcd(0x81);	// set contrast control register
	transfer_command_lcd(0xFF);
	transfer_command_lcd(0xa1);	// set segment re-map 0 to 127
	transfer_command_lcd(0xa6);	// set normal display
	transfer_command_lcd(0xa8);	// set multiplex ratio(1 to 64)
	transfer_command_lcd(0x3F);	//
	transfer_command_lcd(0xa4);	// 0xa4,Output follows RAM content;0xa5,Output ignores RAM content
	transfer_command_lcd(0xd3);	// set display offset
	transfer_command_lcd(0x00);	// not offset
	transfer_command_lcd(0xd5);	// set display clock divide ratio/oscillator frequency
	transfer_command_lcd(0xf0);	// set divide ratio
	transfer_command_lcd(0xd9);	// set pre-charge period
	transfer_command_lcd(0x22);	//
	transfer_command_lcd(0xda);	// set com pins hardware configuration
	transfer_command_lcd(0x12);
	transfer_command_lcd(0xdb);	// set vcomh
	transfer_command_lcd(0x20);	// 0x20,0.77xVcc
	transfer_command_lcd(0x8d);	// set DC-DC enable
	transfer_command_lcd(0x14);	//
	transfer_command_lcd(0xaf);	// turn on oled panel 
	lcd_cs1(1);
		
	show_oled(0);
}

// 全屏清屏
void clear_screen(void)
{
	u8 i, j;
	
	lcd_cs1(0);
	Rom_CS(1);	
	for(i=0; i<8; i++)
	{
		transfer_command_lcd(0xb0+i);
		transfer_command_lcd(0x00);
		transfer_command_lcd(0x10);
		for(j=0; j<128; j++)transfer_data_lcd(0x00);
	}
 	lcd_cs1(1);
}

// 送指令到晶联讯字库IC
void send_command_to_ROM(u8 datu)
{
	u8 i;
	
	for(i=0; i<8; i++ )
	{
		if(datu&0x80){lcd_sid(1);__nop();}
		else{lcd_sid(0); __nop();}
		datu = datu<<1;
		lcd_sclk(0);__nop();
		lcd_sclk(1);__nop();
	}
}

// 从晶联讯字库IC中取汉字或字符数据（1个字节）
static u8 get_data_from_ROM(void)
{
	u8 i, ret_data = 0;
	
	lcd_sclk(1);__nop();
	GBZK_ROMOUTSET();
	for(i=0;i<8;i++)
	{
		Rom_OUT(1);__nop();
		lcd_sclk(0);__nop();
		ret_data = ret_data<<1;
		if(ROM_OUT){ret_data = ret_data+1;__nop();}
		else{ret_data = ret_data+0;__nop();}
		lcd_sclk(1);
	}
	GBZK_ROMOUTRESET();
	return(ret_data);
}

// 从addr(H+M+L)读DataLen长的数据
void get_n_bytes_data_from_ROM(u8 addrHigh, u8 addrMid, u8 addrLow, u8 *pBuff, u8 DataLen )
{
	u8 i;
	
	Rom_CS(0);
	lcd_cs1(1);	
	lcd_sclk(0);
	send_command_to_ROM(0x03);
	send_command_to_ROM(addrHigh);
	send_command_to_ROM(addrMid);
	send_command_to_ROM(addrLow);
	for(i=0; i<DataLen; i++)*(pBuff+i) = get_data_from_ROM();
	Rom_CS(1);
}

void lcd_address(u8 page, u8 column)
{
	transfer_command_lcd(0xb0 + column);				// 设置页地址
	transfer_command_lcd(((page & 0xf0) >> 4) | 0x10);	// 设置列地址的高4位
	transfer_command_lcd((page & 0x0f) | 0x00);			// 设置列地址的低4位
}

// 显示16x16点阵图像、汉字、生僻字或16x16点阵的其他图标
void display_graphic_16x16(u16 page, u16 column, const u8 *dp)
{
	u16 i, j;
 	lcd_cs1(0);
	Rom_CS(1);
	for(j=2; j>0; j--)
	{
		lcd_address(column,page);
		for (i=0; i<16; i++)
		{
			transfer_data_lcd(*dp);	// 写数据到LCD,每写完一个8位的数据后列地址自动加1
			dp++;
		}
		page++;
	}
	lcd_cs1(1);
}

// 显示8x16点阵图像、ASCII, 或8x16点阵的自造字符、其他图标
void display_graphic_8x16(u16 page, u8 column, u8 *dp)
{
	u16 i,j;
	lcd_cs1(0);
	for(j=2;j>0;j--)
	{
		lcd_address(column,page);
		for (i=0; i<8; i++)
		{
			transfer_data_lcd(*dp);	// 写数据到LCD,每写完一个8位的数据后列地址自动加1
			dp++;
		}
		page++;
	}
	lcd_cs1(1);
}

void display_GB2312_string(u8 y, u8 x, u8 *text)
{
	u8 i= 0;
	u8 addrHigh, addrMid, addrLow;
	u8 fontbuf[32];
	
	while(text[i] > 0x00)
	{
		if(((text[i]>=0xb0)&&(text[i]<=0xf7)) && (text[i+1]>=0xa1))
		{						
			// 国标简体（GB2312）汉字在晶联讯字库IC中的地址由以下公式来计算：
			// Address = ((MSB - 0xB0) * 94 + (LSB - 0xA1)+ 846)*32+ BaseAdd;BaseAdd=0
			// 由于担心8位单片机有乘法溢出问题，所以分三部取地址
			fontaddr = (text[i]- 0xb0)*94; 
			fontaddr += (text[i+1]-0xa1)+846;
			fontaddr = (u32)(fontaddr*32);
			
			addrHigh = (fontaddr&0xff0000)>>16;		// 地址的高8位,共24位
			addrMid = (fontaddr&0xff00)>>8;			// 地址的中8位,共24位
			addrLow = fontaddr&0xff;				// 地址的低8位,共24位
			get_n_bytes_data_from_ROM(addrHigh, addrMid, addrLow, fontbuf, 32);
			display_graphic_16x16(y, x, fontbuf);	// y为页地址，x为列地址
			i+=2;
			x+=16;
		}
		else if(((text[i]>=0xa1)&&(text[i]<=0xa3)) && (text[i+1]>=0xa1))
		{						
			// 国标简体（GB2312）15x16点的字符在晶联讯字库IC中的地址由以下公式来计算：
			// Address = ((MSB - 0xa1) * 94 + (LSB - 0xA1))*32+ BaseAdd;BaseAdd=0
			// 由于担心8位单片机有乘法溢出问题，所以分三部取地址
			fontaddr = (text[i]- 0xa1)*94; 
			fontaddr += (text[i+1]-0xa1);
			fontaddr = (u32)(fontaddr*32);
			
			addrHigh = (fontaddr&0xff0000)>>16;
			addrMid = (fontaddr&0xff00)>>8;
			addrLow = fontaddr&0xff;
			get_n_bytes_data_from_ROM(addrHigh, addrMid, addrLow, fontbuf, 32);
			display_graphic_16x16(y, x, fontbuf);
			i+=2;
			x+=16;
		}
		else if((text[i]>=0x20) &&(text[i]<=0x7e))	
		{						
			u8 fontbuf[16];			
			fontaddr = (text[i]- 0x20);
			fontaddr = (u32)(fontaddr*16);
			fontaddr = (u32)(fontaddr+0x3cf80);			
			addrHigh = (fontaddr&0xff0000)>>16;
			addrMid = (fontaddr&0xff00)>>8;
			addrLow = fontaddr&0xff;

			get_n_bytes_data_from_ROM(addrHigh, addrMid, addrLow, fontbuf, 16);			
			display_graphic_8x16(y, x, fontbuf);	// 显示8x16的ASCII字
			i+=1;
			x+=8;
		}
		else i++;
	}
	
}

// 显示128x64点阵图像
void display_128x64(const u8 *dp)
{
	u16 i,j;
	lcd_cs1(0);
	for(j=0; j<8; j++)
	{
		lcd_address(0,j);
		for (i=0; i<128; i++)
		{	
			transfer_data_lcd(*dp);	// 写数据到LCD,每写完一个8位的数据后列地址自动加1
			dp++;
		}
	}
	lcd_cs1(1);
}

// 显示5*7点阵图像、ASCII, 或5x7点阵的自造字符、其他图标
void display_graphic_5x7(u16 page, u8 column, u8 *dp)
{
	u16 col_cnt;
	u8 page_address;
	u8 column_address_L,column_address_H;
	page_address = 0xb0+page-1;
	
	lcd_cs1(0);	
	
	column_address_L =(column&0x0f)-1;
	column_address_H =((column>>4)&0x0f)+0x10;
	
	transfer_command_lcd(page_address);		// Set Page Address
	transfer_command_lcd(column_address_H);	// Set MSB of column Address
	transfer_command_lcd(column_address_L);	// Set LSB of column Address
	
	for (col_cnt=0;col_cnt<6;col_cnt++)
	{	
		transfer_data_lcd(*dp);
		dp++;
	}
	lcd_cs1(1);
}

void display_string_5x7(u8 y, u8 x, u8 *text)
{
	u8 i= 0;
	u8 addrHigh, addrMid, addrLow ;
	while((text[i]>0x00))
	{
		if((text[i]>=0x20) &&(text[i]<=0x7e))	
		{						
			unsigned char fontbuf[8];			
			fontaddr = (text[i]- 0x20);
			fontaddr = (unsigned long)(fontaddr*8);
			fontaddr = (unsigned long)(fontaddr+0x3bfc0);			
			addrHigh = (fontaddr&0xff0000)>>16;
			addrMid = (fontaddr&0xff00)>>8;
			addrLow = fontaddr&0xff;

			get_n_bytes_data_from_ROM(addrHigh,addrMid,addrLow,fontbuf,8);
			
			display_graphic_5x7(y,x,fontbuf);	//显示5x7的ASCII字到LCD上
			i+=1;
			x+=6;
		}
		else
		i++;	
	}
}

void show_oled(u8 page)
{
	char buf[16];
	
	clear_screen();
	if(page != 0)
	{		
		if(SIM_CON_OK == 0)display_graphic_16x16(0, 0, GSMLOSS);
		else display_graphic_16x16(0, 0, GSMGET);
		
		if(linkState == 0)display_graphic_16x16(0, 16, LANLOSS);
		else display_graphic_16x16(0, 16, LANGET);
		
//		display_graphic_16x16(0, 32, BAT);
		
		linkState = 0;
	}
	
	switch(page)
	{
	case 0:
	{
		display_128x64(logo);
		display_GB2312_string(1,72,(u8 *)"超视野");
		display_GB2312_string(3,72,(u8 *)"SmartCa");
		display_GB2312_string(5,72,(u8 *)ReleaseVersion);
		break;
	}
	case 1:
	{
		display_GB2312_string(0,64,(u8 *)"本机IP:");
		sprintf(buf, "%03d.%03d.%03d.%03d", lwipdev.ip[0], lwipdev.ip[1], lwipdev.ip[2], lwipdev.ip[3]);
		display_GB2312_string(2,0,(u8 *)buf);
		sprintf(buf, "%03d.%03d.%03d.%03d", lwipdev.netmask[0], lwipdev.netmask[1], lwipdev.netmask[2], lwipdev.netmask[3]);
		display_GB2312_string(4,0,(u8 *)buf);
		sprintf(buf, "%03d.%03d.%03d.%03d", lwipdev.gateway[0], lwipdev.gateway[1], lwipdev.gateway[2], lwipdev.gateway[3]);
		display_GB2312_string(6,0,(u8 *)buf);
		break;
	}
	case 2:
	{
		display_GB2312_string(0,64,(u8 *)"MQTTIP:");
		sprintf(buf, "%03d.%03d.%03d.%03d", lwipdev.mqttip[0], lwipdev.mqttip[1], lwipdev.mqttip[2], lwipdev.mqttip[3]);
		display_GB2312_string(2,0,(u8 *)buf);
		sprintf(buf, "PORT: %d", lwipdev.mqttport);
		display_GB2312_string(4,0,(u8 *)buf);
		break;
	}
	case 3:
	{
		display_GB2312_string(0,64,(u8 *)"SNMPIP:");
		sprintf(buf, "%03d.%03d.%03d.%03d", lwipdev.snmpip[0], lwipdev.snmpip[1], lwipdev.snmpip[2], lwipdev.snmpip[3]);
		display_GB2312_string(2,0,(u8 *)buf);
		sprintf(buf, "PORT: %d", lwipdev.snmpport);
		display_GB2312_string(4,0,(u8 *)buf);
		break;
	}
	case 4:
	{
		display_GB2312_string(0,64,(u8 *)"经纬度:");
		sprintf(buf, "%c: %d.%d", gpsxSC.nshemi, gpsxSC.latitude/100000, gpsxSC.latitude%100000);
		display_GB2312_string(2,0,(u8 *)buf);
		sprintf(buf, "%c: %d.%d", gpsxSC.ewhemi, gpsxSC.longitude/100000, gpsxSC.longitude%100000);
		display_GB2312_string(4,0,(u8 *)buf);
		break;
	}
	case 5:
	{
		sprintf(buf, "VOL: %.2f V", VOL);
		display_GB2312_string(2,0,(u8 *)buf);
		sprintf(buf, "CUR: %.2f A", CUR);
		display_GB2312_string(4,0,(u8 *)buf);
		sprintf(buf, "%.1f℃, %.1f%%", TEM, HUM);
		display_GB2312_string(6,0,(u8 *)buf);
		break;
	}
	default:
		break;
	}
}
